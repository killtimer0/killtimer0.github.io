<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>光速虚拟机逆向分析 --verbose | 轮子部落</title><meta name="keywords" content="reverse"><meta name="author" content="KillTimer"><meta name="copyright" content="KillTimer"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="属于是逆出感情来了">
<meta property="og:type" content="article">
<meta property="og:title" content="光速虚拟机逆向分析 --verbose">
<meta property="og:url" content="https://killtimer0.github.io/2022/08/30/VPhone-Reverse/index.html">
<meta property="og:site_name" content="轮子部落">
<meta property="og:description" content="属于是逆出感情来了">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2022-08-30T01:03:43.000Z">
<meta property="article:modified_time" content="2022-10-20T14:44:45.614Z">
<meta property="article:author" content="KillTimer">
<meta property="article:tag" content="reverse">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://killtimer0.github.io/2022/08/30/VPhone-Reverse/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '光速虚拟机逆向分析 --verbose',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-10-20 22:44:45'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_2790816_84e2ai83qxf.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.min.css" media="defer" onload="this.media='all'"><script async src="https://cdn.jsdelivr.net/npm/hexo-butterfly-tag-plugins-plus@latest/lib/carousel-touch.min.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/loading.svg" data-original="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">轮子部落</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">光速虚拟机逆向分析 --verbose</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-30T01:03:43.000Z" title="发表于 2022-08-30 09:03:43">2022-08-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-10-20T14:44:45.614Z" title="更新于 2022-10-20 22:44:45">2022-10-20</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>32分钟</span></span></div></div></div><article class="post-content" id="article-container"><div class="note info flat"><p><strong>2022-10-20更新</strong></p>
<p>最近有些人@我让我教他们教程具体怎么操作，我感到奇怪并问他们怎么回事，因为我没有对外发布过这篇文章，这只是我逆向实战的一个研究记录。然后我发现这个教程已经出现在了很多平台上，这让我感到非常惊讶，因为<strong>作者没有在任何论坛或群聊等公开发布过这篇文章</strong>。如果那些地方有人称自己是作者，那么他那句话一定是假的。当然如果有人想走一遍教程并且学习相关知识，却碰到教程中的遗漏和错误，欢迎来咨询我（Q1837009039）。但如果你只需要最后的破解结果，那你找错人了，<strong>作者不提供破解成品</strong>，实在需要的话找那些走教程破解成功的人吧，他们走一遍教程而且弄对也挺不容易的。这篇文章需要你具备一些IDA和Python的知识，如果你不知道这些是什么，可以找除我以外的其他人帮忙。破解适用于版本2.4.0(3327)和当前最新版3.0.0(3328,3330)，但估计下一个版本官方会加入更多的防破解措施，所以如果你很期待APP的新功能的话，我<strong>推荐购买正版</strong>，花很大劲去整一个盗版软件不值得。而这篇教程也会成为历史，且看且珍惜吧。</p>
</div>
<p>之前需要动态调试几个apk，于是准备在电脑上装一个安卓模拟器。但是我需要经常用到wsl，而它需要开启hyper-v功能，众所周知这个功能与大部分的安卓模拟器冲突。一开始我安装了wsa（windows安卓子系统），可惜的是它的兼容性不是很好，而且对于ida的动态调试，经常无法命中断点，而且看不到寄存器的状态，后面又尝试了几个能与hyper-v共存的模拟器，都有类似的问题。我怀疑是android_server的锅，然后拿gdbserver又试了一下，看到了下面的提示信息：</p>
<p><img src="/img/loading.svg" data-original="/pictures/VPhone-Reverse/01.png" alt="gdbserver的错误报告"></p>
<p>gdbserver也获取不到寄存器，猜测是架构的问题，在电脑上找模拟器这条路就放弃了。</p>
<p>于是我又去试了真机调试，能做到，但还是想要一个能root的设备，所以我安装了vmos pro，在设置中打开网络adb，也能够进行调试。然而vmos的root总感觉怪怪的，我调试apk时，想用gg修改器导出内存，但它始终检测不到root的存在，一直卡在启动界面。然后我去找了其他的虚拟机，发现这个光速虚拟机能正常用root，而且支持magisk和安卓10，这正好能解决打ctf时一些应用SDK版本高于模拟器安卓支持的最高版本导致不能启动的问题。但应用启动时广告很多，而且大部分特性仅限会员，在网上也找不到比较新的破解版，然后就想自己尝试一下，就诞生了这篇文章。</p>
<h2 id="Java层初探"><a href="#Java层初探" class="headerlink" title="Java层初探"></a>Java层初探</h2><p>我下载的版本是当前的最新版2.4.0，与上一版本2.3.1相比它新增一个多开管理的功能，于是就想从这个版本入手。先什么也不改，对应用直接签名，结果启动时出现<code>initialize feature fail(51)</code>错误，那应该就有什么验签机制。</p>
<p><img src="/img/loading.svg" data-original="/pictures/VPhone-Reverse/02.png" alt="启动失败"></p>
<p>用mt管理器自带的去除签名校验处理了一下，发现并不可行。在classes.dex中搜索base64字符串，结果只发现了微信SDK的签名，这个应该不是我们想要的，那验签逻辑应该在native层了。再看一眼Java层代码，发现这个应用并没有进行名称混淆，一些类似<code>isVip</code>字样的方法名十分的显眼：</p>
<p><img src="/img/loading.svg" data-original="/pictures/VPhone-Reverse/03.png" alt="逆向的代码"></p>
<p>那么看来过签后vip的破解会比较轻松，于是就想着把验签的逻辑找出来就万事大吉了<del>事实证明我这个想法还是太太太太年轻了</del>。</p>
<h2 id="Native层—签名验证"><a href="#Native层—签名验证" class="headerlink" title="Native层—签名验证"></a>Native层—签名验证</h2><p>通过对几个so文件的观察，猜测可能的so有4个：<code>libuserkernel*.so</code>和<code>libVPhoneGaGaLib.so</code>，其他so要么太小，要么名称在网上可以直接搜到（比如<code>libp7zip.so</code>），应该不会有验签逻辑：</p>
<p><img src="/img/loading.svg" data-original="/pictures/VPhone-Reverse/04.png" alt="native文件"></p>
<p>其中前者有3个版本，分别是两个32位版和一个64位版（为什么有两个32位版我现在还没弄清楚）。<code>libVPhoneGaGaLib.so</code>文件最大，于是就先从这个so入手。</p>
<p>用IDA打开这个文件，发现代码中布满了这样的操作：</p>
<p><img src="/img/loading.svg" data-original="/pictures/VPhone-Reverse/05.png" alt="字符串加密"></p>
<p>这很明显是字符串加密，随便解了几个，字符串的内容大概有函数的名称，日志文本之类的。然而我们不可能一个个进行处理。经过观察，我发现很多这种加密文本的代码段都有这样的格式：</p>
<ul>
<li><p>把一些数放到寄存器中</p>
</li>
<li><p>把寄存器中的数写入栈内</p>
</li>
<li><p>for循环，对字符逐个异或解密，解密方法有两类：<code>x ^= i + c</code>和<code>x ^= c</code>。<code>c</code>是一个常数，<code>i</code>是字符的位置。</p>
</li>
</ul>
<p>可以用这种模式去遍历整个代码段，找到它们的位置，然后用Unicorn模拟执行引擎来解一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> argv</span><br><span class="line"><span class="keyword">from</span> elftools.elf.elffile <span class="keyword">import</span> ELFFile, Section</span><br><span class="line"><span class="keyword">from</span> capstone <span class="keyword">import</span> Cs, CS_ARCH_ARM64, CS_MODE_ARM</span><br><span class="line"><span class="keyword">from</span> unicorn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> unicorn.arm64_const <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(argv) &gt;= <span class="number">2</span></span><br><span class="line">so = ELFFile(<span class="built_in">open</span>(argv[<span class="number">1</span>], <span class="string">&#x27;rb&#x27;</span>))</span><br><span class="line">section: Section = so.get_section_by_name(<span class="string">&#x27;.text&#x27;</span>)</span><br><span class="line">base: <span class="built_in">int</span> = section.header.sh_addr</span><br><span class="line">code = section.data()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._ops = <span class="built_in">set</span>(<span class="string">&#x27;mov str movz ldp ldr adrp add sub movi ldrh and strh orr ldrb subs ldurb ldur strb eor sturb lsr movn movk csinc madd ubfx asr mul cmn lsl nop cinc ext sxtw smaddl fcvtzs udiv msub smull ldrsw smulh adds mvn neg sturh umull csneg umov sshll sdiv ldrsb stlrb bfi ands sxtb ushl umaddl umulh sxth bic orn ror rev sbfiz ldursw bfxil sbfx ldpsw ldrsh&#x27;</span>.split())</span><br><span class="line">        self._pat = (<span class="string">&#x27;ldrb ldr add eor strb add cmp b.ne&#x27;</span>, <span class="string">&#x27;ldrb ldr eor strb add cmp b.ne&#x27;</span>, <span class="string">&#x27;ldrb ldur add eor strb add cmp b.ne&#x27;</span>, <span class="string">&#x27;ldrb ldur eor strb add cmp b.ne&#x27;</span>)</span><br><span class="line">        self._pat = <span class="built_in">tuple</span>(<span class="built_in">tuple</span>(item.split()) <span class="keyword">for</span> item <span class="keyword">in</span> self._pat)</span><br><span class="line">        self._step = [<span class="number">0</span>] * <span class="built_in">len</span>(self._pat)</span><br><span class="line">        self._<span class="built_in">set</span> = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self, addr, op</span>):</span></span><br><span class="line">        match = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> op <span class="keyword">in</span> self._ops:</span><br><span class="line">            self._<span class="built_in">set</span>.add(addr)</span><br><span class="line">        <span class="keyword">for</span> i, pat <span class="keyword">in</span> <span class="built_in">enumerate</span>(self._pat):</span><br><span class="line">            <span class="keyword">if</span> op == pat[self._step[i]]:</span><br><span class="line">                self._step[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: self._step[i] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> self._step[i] == <span class="built_in">len</span>(pat):</span><br><span class="line">                self._step[i] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">assert</span> match <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line">                match = i</span><br><span class="line">        <span class="keyword">if</span> match <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            pos = <span class="literal">None</span></span><br><span class="line">            end = addr - <span class="number">4</span> * <span class="built_in">len</span>(self._pat[match]) + <span class="number">4</span></span><br><span class="line">            <span class="keyword">for</span> p <span class="keyword">in</span> <span class="built_in">range</span>(end - <span class="number">4</span>, -<span class="number">4</span>, -<span class="number">4</span>):</span><br><span class="line">                <span class="keyword">if</span> p <span class="keyword">in</span> self._<span class="built_in">set</span>:</span><br><span class="line">                    pos = p</span><br><span class="line">                <span class="keyword">else</span>: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">assert</span> pos <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">return</span> pos, end</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataRecorder</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.reset()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reset</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._current = <span class="literal">None</span></span><br><span class="line">        self._data = <span class="literal">None</span></span><br><span class="line">        self.enable = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hit</span>(<span class="params">self, addr, data</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.enable:</span><br><span class="line">            <span class="keyword">if</span> self._current <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                self._current = addr</span><br><span class="line">                self._data = <span class="built_in">bytearray</span>()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self._current += <span class="number">1</span></span><br><span class="line">                <span class="keyword">assert</span> addr == self._current</span><br><span class="line">            self._data.append(data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">finish</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = self._data.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        <span class="keyword">except</span> UnicodeDecodeError:</span><br><span class="line">            data = <span class="built_in">bytes</span>(self._data)</span><br><span class="line">        self.reset()</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">onmemwrite</span>(<span class="params">uc: Uc, kind: <span class="built_in">int</span>, addr: <span class="built_in">int</span>, size: <span class="built_in">int</span>, value: <span class="built_in">int</span>, dr: DataRecorder</span>):</span></span><br><span class="line">    <span class="keyword">if</span> kind == UC_MEM_WRITE:</span><br><span class="line">        <span class="keyword">assert</span> size == <span class="number">1</span> <span class="keyword">or</span> <span class="keyword">not</span> dr.enable</span><br><span class="line">        dr.hit(addr, value)</span><br><span class="line">        uc.mem_write(addr, <span class="built_in">int</span>.to_bytes(value &amp; (<span class="number">1</span> &lt;&lt; (size &lt;&lt; <span class="number">3</span>)) - <span class="number">1</span>, size, <span class="string">&#x27;little&#x27;</span>))</span><br><span class="line">    <span class="keyword">else</span>: <span class="keyword">assert</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">uc = Uc(UC_ARCH_ARM64, UC_MODE_ARM)</span><br><span class="line">uc.mem_map(base, (<span class="built_in">len</span>(code) + <span class="number">0xFFF</span>) // <span class="number">0x1000</span> * <span class="number">0x1000</span>, UC_PROT_READ | UC_PROT_EXEC)</span><br><span class="line">uc.mem_write(base, code)</span><br><span class="line">stack = (base + <span class="built_in">len</span>(code) + <span class="number">0x1000</span>) // <span class="number">0x1000</span> * <span class="number">0x1000</span></span><br><span class="line">stack_size = <span class="number">0x100000</span></span><br><span class="line">uc.mem_map(stack, stack_size, UC_PROT_READ | UC_PROT_WRITE)</span><br><span class="line">uc.reg_write(UC_ARM64_REG_SP, stack)</span><br><span class="line">dr = DataRecorder()</span><br><span class="line">uc.hook_add(UC_HOOK_MEM_WRITE, onmemwrite, dr, stack, stack + stack_size - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">state = State()</span><br><span class="line">cs = Cs(CS_ARCH_ARM64, CS_MODE_ARM)</span><br><span class="line">current = base</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> current != base + <span class="built_in">len</span>(code):</span><br><span class="line">    <span class="keyword">for</span> addr, _, op, operand <span class="keyword">in</span> cs.disasm_lite(code[current-base:], current):</span><br><span class="line">        current = addr</span><br><span class="line">        result = state.update(addr, op)</span><br><span class="line">        <span class="keyword">if</span> result <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            start, mid = result</span><br><span class="line">            end = addr + <span class="number">4</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;found encrypted string at 0x%X 0x%X 0x%X: &#x27;</span> % (*result, end), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">                uc.emu_start(start, mid)</span><br><span class="line">                dr.enable = <span class="literal">True</span></span><br><span class="line">                uc.emu_start(mid, end)</span><br><span class="line">                <span class="built_in">print</span>(<span class="built_in">repr</span>(dr.finish()))</span><br><span class="line">            <span class="keyword">except</span> (UcError, AssertionError) <span class="keyword">as</span> e:</span><br><span class="line">                <span class="built_in">print</span>(<span class="built_in">repr</span>(e))</span><br><span class="line">                dr.reset()</span><br><span class="line">    current += <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>简单解释一下思路：代码逐句反编译后，脚本会识别解密循环的固定模式，然后向前（小地址方向）尽可能长地匹配除跳转指令等以外的所有指令，这样就能把解密字符串时的寄存器状态最大程度还原出来。每识别到一个这样的模式，就让Unicorn先运行循环前的代码，这时栈中字符已经放置好了，然后开启写内存的记录器，再来运行循环代码，于是栈上的字符被逐个解密，我们也通过hook知道了解密后的字符序列。运行脚本之后，的确解出了不少字符串：</p>
<p><img src="/img/loading.svg" data-original="/pictures/VPhone-Reverse/06.png" alt="解密的字符串"></p>
<p>然而这种方法无法应对一些情况。原因是这些字符串的解密代码都是C++动态生成的，既然是编译器，那它想怎么做就怎么做，只要最后生成的代码能达到目的就行，而我们只能识别一些固定模式。例如一个字符串过短时，C++编译时自动展开循环，就没有for的过程，我们就检测不到；又或者C++认为这个解密函数不应该内联，那for循环代码就变成了函数调用，我们也检测不到；还有一种是寄存器在很早以前就赋值了，但我们在Unicorn中模拟执行的时候不知道这一点，结果执行时输出错误结果或者直接报错，就像上图那样。循环展开这种情况比较好解决：直接IDA Ctrl+F5导出全部代码，IDA会帮我们自动还原字符串。剩下的情况现在我还没有想到什么好的办法。总结下来，这个脚本能解密出来的字符串还不到二分之一，但这个解密结果对接下来的逆向分析帮助还是很大的。</p>
<p>先写个IDA脚本，把这些字符串中看着像方法名的给函数重新命名，成功还原了一百来个方法名：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re, idaapi</span><br><span class="line"></span><br><span class="line">raw = <span class="built_in">open</span>(<span class="string">&#x27;out.txt&#x27;</span>).read()</span><br><span class="line"></span><br><span class="line">raw, namef, mapf = raw.splitlines(), <span class="built_in">set</span>(), &#123;&#125;</span><br><span class="line">pat = re.<span class="built_in">compile</span>(<span class="string">&#x27;.*?0x([\dA-Fa-f]+): .*?([A-Za-z_][A-Za-z\d_]*::[A-Za-z_][A-Za-z\d_]*).*?&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> raw:</span><br><span class="line">    match = pat.fullmatch(line)</span><br><span class="line">    <span class="keyword">if</span> match <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        addr, name = <span class="built_in">int</span>(match.group(<span class="number">1</span>), <span class="number">16</span>), match.group(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> namef:</span><br><span class="line">            mapf[addr] = name</span><br><span class="line">            namef.add(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> addr, name <span class="keyword">in</span> mapf.items():</span><br><span class="line">    func: idaapi.func_t = idaapi.get_func(addr)</span><br><span class="line">    addr = func.start_ea</span><br><span class="line">    idaapi.set_name(addr, name)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;0x%x -&gt; %s&#x27;</span> % (addr, name))</span><br></pre></td></tr></table></figure>
<p><img src="/img/loading.svg" data-original="/pictures/VPhone-Reverse/07.png" alt="还原的函数"></p>
<p>然后我们直接搜索应用提示启动失败的字符串，找到了一个，在<code>Engine::StartEngine</code>函数中：</p>
<p><img src="/img/loading.svg" data-original="/pictures/VPhone-Reverse/08.png" alt="验签提示"></p>
<p>往前翻到上一个分支，那么验签的主要函数就找到了，把它随便命名一下，然后点开函数，往下一滑就找到了一个<code>memcmp</code>函数：</p>
<p><img src="/img/loading.svg" data-original="/pictures/VPhone-Reverse/09.png" alt="验签结果"></p>
<p>通过对<code>0x4DBF22</code>处的内容进行分析，结合长度为<code>0x14</code>这一特征，可以发现这是签名的SHA1值。那么后面就简单了，修改函数返回值或者<code>0x4DBF22</code>处的数据即可过签。</p>
<h2 id="Native层—数据验证"><a href="#Native层—数据验证" class="headerlink" title="Native层—数据验证"></a>Native层—数据验证</h2><p>然而实际上修改后再安装发现，应用进入后会直接黑屏。。。但是如果我们不去修改<code>classes.dex</code>文件又不会黑屏（但是会出现购买vip的弹窗）。通过对几个文件的修改得知，如果修改下列文件之一，应用就会黑屏：<code>classes.dex</code>，<code>classes2.dex</code>，<code>classes3.dex</code>，<code>AndroidManifest.xml</code>。即使只在<code>AndroidManifest.xml</code>后面再加几个字节也会黑屏，所以猜测应用对这几个关键文件有另一个验证机制。然后在so中继续找了很久，还是没有什么头绪。在找的过程中看了很多函数，如果碰到有加密字符串的，就手动解密字符串并且还原函数名，还有一些函数名是根据它的行为猜测的（这些函数一般以<code>xxx</code>开头，而且会注明），所以后文如果看到一些莫名其妙的函数名，不用感到奇怪。</p>
<p>在一开始过签失败的弹窗中可以发现，这个应用会生成一些加密的日志。于是我很好奇应用的日志打印在哪，和它的解密方式，分析之后发现日志在<code>/sdcard/Android/data/com.vphonegaga.titan/files/instanceX/logs</code>中，日志记录方式如下<del>一大片红请忽略</del>：</p>
<p><img src="/img/loading.svg" data-original="/pictures/VPhone-Reverse/10.png" alt="写出日志"></p>
<p><code>log_encode</code>函数就是加密过程（函数名随便起的），通过简单分析，可以看出这是RC4加密，密码是<code>unhexlify(&#39;206DEA86C313F2E3&#39;)</code>。先写个解密脚本试试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> unhexlify</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> ARC4</span><br><span class="line"><span class="keyword">import</span> os, re</span><br><span class="line"></span><br><span class="line">pat = re.<span class="built_in">compile</span>(<span class="string">&#x27;^(\[\d+\])&#123;2&#125;\[(\d\d:)&#123;2&#125;\d\d.\d&#123;3&#125;\]: &#x27;</span>, re.M)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">dir</span>, _, files <span class="keyword">in</span> os.walk(<span class="string">&#x27;patch/logs&#x27;</span>):</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> <span class="built_in">map</span>(<span class="keyword">lambda</span> x: os.path.join(<span class="built_in">dir</span>, x), files):</span><br><span class="line">        rc = ARC4.new(unhexlify(<span class="string">&#x27;206DEA86C313F2E3&#x27;</span>))</span><br><span class="line">        <span class="keyword">if</span> file.endswith(<span class="string">&#x27;.log&#x27;</span>):</span><br><span class="line">            data = rc.decrypt(<span class="built_in">open</span>(file, <span class="string">&#x27;rb&#x27;</span>).read()).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">            data = pat.sub(<span class="string">&#x27;&#x27;</span>, data)</span><br><span class="line">            <span class="built_in">open</span>(file, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>).write(data)</span><br></pre></td></tr></table></figure>
<p>成功解密出4个日志文件：</p>
<p><img src="/img/loading.svg" data-original="/pictures/VPhone-Reverse/11.png" alt="日志"></p>
<p>然后看看黑屏与不黑屏的日志有什么不同。可以使用<code>git diff file1 file2</code>直观的比对文件内容。比对下来发现两次<code>titan.log</code>除了顺序不同并无异常，<code>AndroidLog.log</code>是虚拟机内部应用的日志，<code>UserKernelApi.log</code>只有几行，只有<code>UserKernel.log</code>中有几百行，而且尽是些不认识的符号，简单分析发现这是<code>libuserkernel*.so</code>中的日志，使用<code>git diff</code>发现一处不明所以的差异：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@1637@@678@0</span><br></pre></td></tr></table></figure>
<p>于是尝试性地打开了<code>libuserkernel64.so</code>，定位到这条字符串处：</p>
<p><img src="/img/loading.svg" data-original="/pictures/VPhone-Reverse/12.png" alt="可疑代码"></p>
<p>然后查看<code>sub_18B758</code>，翻到最后，发现下面的代码：</p>
<p><img src="/img/loading.svg" data-original="/pictures/VPhone-Reverse/13.png" alt="验证逻辑"></p>
<p>通过前面的代码发现应用运行时会把<code>0x3213C0</code>处的一些片段异或<code>0x86</code>，那我们也尝试异或一下，结果豁然开朗：这个函数会对<code>META-INF/KEY0.RSA</code>、<code>AndroidManifest.xml</code>、<code>classes.dex</code>、<code>classes2.dex</code>、<code>classes3.dex</code>、<code>META-INF/KEY0.SF</code>进行长度和CRC的校验（如果CRC=0就不验证，因为第一个和最后一个文件是签名相关文件，在应用打包之前内容是未知的，没办法验证）。那么我们把对应CRC的位置都改成0即可，但是注意<code>libuserkernel*.so</code>有三个，它们都需要改。改完以后验证成功通过。</p>
<h2 id="Native层—VIP验证"><a href="#Native层—VIP验证" class="headerlink" title="Native层—VIP验证"></a>Native层—VIP验证</h2><p>光速虚拟机的安卓ROM有两个，分别是安卓7和安卓10。破解前面两处校验后，再次打包运行，发现安卓7能正常使用了，但是安卓10界面点不动，悬浮窗中的导航键也没反应，而悬浮窗中的“展开通知栏”功能是可以正常使用的。这个问题我找字符串无从下手，因为此现象无法提供更多信息，然后我对着so逆了很久，最后只知道触摸输入最后传到了<code>0x240FA8</code>处，悬浮窗输入传到了<code>0x95490</code>处。于是简单学了下frida入门教程，边学边用，尝试拦截并记录运行时函数的调用信息。一路跟着函数调用，我发现应用最后把输入数据包传到了<code>pipe_stream::write_fully(0x27369C)</code>中。这个函数的第一个参数是<code>this</code>指针，第二、三个是发送的数据和长度。函数调用<code>sendto</code>函数把数据包发送出去，可以在发送前调用libc函数查看传入<code>sendto</code>的文件描述符：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPathById</span>(<span class="params">fd</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (readlink === <span class="literal">undefined</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> readlink_addr = Module.findExportByName(<span class="string">&#x27;libc.so&#x27;</span>, <span class="string">&#x27;readlink&#x27;</span>)</span><br><span class="line">        readlink = <span class="keyword">new</span> NativeFunction(readlink_addr, <span class="string">&#x27;ssize_t&#x27;</span>, [<span class="string">&#x27;pointer&#x27;</span>, <span class="string">&#x27;pointer&#x27;</span>, <span class="string">&#x27;size_t&#x27;</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> path = Memory.allocUtf8String(<span class="string">`/proc/self/fd/<span class="subst">$&#123;fd&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">let</span> buf = Memory.alloc(<span class="number">256</span>)</span><br><span class="line">    <span class="keyword">let</span> retLen = readlink(path, buf, <span class="number">256</span>)</span><br><span class="line">    <span class="keyword">if</span> (retLen &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;getPathById: readlink fails&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> buf.readUtf8String(retLen)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果显示这是一个socket，用<code>netstat -ax</code>查看，发现这是一个unix domain socket。用这个函数获取socket的名字：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSocketNameById</span>(<span class="params">fd</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getsockname === <span class="literal">undefined</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> getsockname_addr = Module.findExportByName(<span class="string">&#x27;libc.so&#x27;</span>, <span class="string">&#x27;getsockname&#x27;</span>)</span><br><span class="line">        getsockname = <span class="keyword">new</span> NativeFunction(getsockname_addr, <span class="string">&#x27;int&#x27;</span>, [<span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;pointer&#x27;</span>, <span class="string">&#x27;pointer&#x27;</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> addr = Memory.alloc(<span class="number">256</span>)</span><br><span class="line">    <span class="keyword">let</span> retLen = Memory.alloc(<span class="number">4</span>).writeUInt(<span class="number">256</span>)</span><br><span class="line">    <span class="keyword">let</span> ret = getsockname(fd, addr, retLen)</span><br><span class="line">    <span class="keyword">if</span> (ret !== <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;getSocketNameById: getsockname fails&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> name = addr.add(<span class="number">3</span>).readUtf8String(retLen.readUInt() - <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到的结果是<code>titan-pipe-1-input-qwerty</code>。再用下面的代码找到这个socket的对端：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSocketTarget</span>(<span class="params">fd</span>)</span>&#123; <span class="comment">// pid uid gid</span></span><br><span class="line">    <span class="keyword">if</span> (getsockopt === <span class="literal">undefined</span>)</span><br><span class="line">        getsockopt = <span class="keyword">new</span> NativeFunction(Module.findExportByName(<span class="string">&#x27;libc.so&#x27;</span>, <span class="string">&#x27;getsockopt&#x27;</span>), <span class="string">&#x27;int&#x27;</span>, [<span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;pointer&#x27;</span>, <span class="string">&#x27;pointer&#x27;</span>])</span><br><span class="line">    <span class="keyword">let</span> addr = Memory.alloc(<span class="number">12</span>)</span><br><span class="line">    <span class="keyword">let</span> len = Memory.alloc(<span class="number">4</span>).writeUInt(<span class="number">12</span>)</span><br><span class="line">    <span class="keyword">let</span> ret = getsockopt(fd, <span class="number">1</span>, <span class="number">17</span>, addr, len)</span><br><span class="line">    <span class="keyword">if</span> (ret !== <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`getSocketTarget: getsockopt fails: <span class="subst">$&#123;ret&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Uint32Array</span>(addr.readByteArray(<span class="number">12</span>)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它得到了对端的pid，uid和gid。<code>ps -A | grep &lt;pid&gt;</code>查看进程名称，结果为<code>titan64_0:kernel</code>。 用IDA附加到此进程，发现里面没有<code>libVPhoneGaGaLib.so</code>，只有<code>libuserkernel64.so</code>。那么对端的代码应该就在这个so里面了。经过寻找，最后找到了关键函数：<code>titan::dev_input::on_input_event_callback(0xA7648)</code>，这个函数循环接收数据包，然后调用<code>process_input(0xA785C)</code>，名字随便起的：</p>
<p><img src="/img/loading.svg" data-original="/pictures/VPhone-Reverse/14.png" alt="输入接收函数"></p>
<p>这里推测29-31行是验证逻辑，因为我对比了2.3.1老版本的同名函数（2.3.1版本还没有这么多奇怪的验证，它在过完前面两个验证后是能接收触摸事件的），确认这几行是新加上来的。然后Ctrl+F5导出所有代码，搜索<code>+ 3605</code>等字样，筛选出给它赋值的，最终定位到了<code>titan::kernel::on_network_event(0xECD20)</code>。这个函数是另一个socket的接收端，它负责与<code>libVPhoneGaGaLib.so</code>通信<del>注意这个函数中有一个巨大的<code>switch-case</code>，以后会考(</del>。于是我们又回到<code>libVPhoneGaGaLib.so</code>中来。</p>
<p>使用frida记录<code>pipe_stream::write_fully(0x27369C)</code>的所有调用，打印他们的文件描述符对应的socket name（如果有）和<code>lr</code>寄存器（函数调用方），最后定位到了<code>HwNetwork::SendPacket(0x244FC8)</code>处，名字随便起的。对此函数查看交叉引用，能定位到好几个函数。经过分析，我发现发送的数据包有如下格式：</p>
<ul>
<li><p>一个四字节的<code>ETEN</code>头（魔法值）</p>
</li>
<li><p>一个四字节整数，标识数据包的类型，取值为1-8共八种</p>
</li>
<li><p>一个八字节整数，存放数据主体的长度</p>
</li>
<li><p>数据主体，定义与数据包类型有关</p>
</li>
</ul>
<p>对<code>libuserkernel64.so</code>中的<code>switch-case</code>进行分析，类型7应该是我们想要的。于是在<code>libVPhoneGaGaLib.so</code>中找到了发送这种数据包的函数： <code>xxxSaveUserVipInfo(0x245A00)</code>，名字随便起的。对此函数查看交叉引用，有<code>Engine::SetUserLogin(0x169F2C)</code>等共三个函数，另两个对逆向作用不大暂时忽略。分析<code>Engine::SetUserLogin</code>函数，这个函数会把Java层中<code>Lcom/vphonegaga/titan/user/User;</code>类的一个实例的<code>uid</code>、<code>token</code>、<code>token2</code>、<code>uuid</code>字段读到<code>Engine</code>中保存。于是<code>xxxSaveUserVipInfo</code>函数的参数就水落石出了：</p>
<ul>
<li><p><code>void *this</code>，推断是<code>HwNetwork</code>类</p>
</li>
<li><p><code>bool bLogin</code>，是否登录</p>
</li>
<li><p><code>const char *uid</code>，用户uid</p>
</li>
<li><p><code>const char *token2</code>，一个token</p>
</li>
<li><p><code>const char *uuid</code>，暂时不清楚有什么用</p>
</li>
<li><p><code>const void *sign1</code>，JNI调用<code>Landroid/content/pm/PackageInfo</code>获取的签名信息</p>
</li>
<li><p><code>unsigned sign1len</code></p>
</li>
<li><p><code>const void *sign2</code>，解析ZIP包中的<code>META-INF/[\w]+\.RSA</code>（正则表达式匹配一个结果）获取的签名信息</p>
</li>
<li><p><code>unsigned sign2len</code></p>
</li>
</ul>
<p>数据包的信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">size: 3180</span><br><span class="line">0000-0004 &#x27;ETEN&#x27;</span><br><span class="line">0004-0008 kind: 7</span><br><span class="line">0008-0016 packLen: 3164</span><br><span class="line">0016-0020 bLogin</span><br><span class="line">0020-0036 uid</span><br><span class="line">0036-1060 token2</span><br><span class="line">1060-1124 uuid</span><br><span class="line">1124-1128 sign1Len</span><br><span class="line">1128-2152 sign1</span><br><span class="line">2152-2156 sign2Len</span><br><span class="line">2156-3180 sign2</span><br></pre></td></tr></table></figure>
<p>把这一结果对应到socket的接收端<code>case 7</code>处，就知道<code>process_input</code>中检验的是什么了。</p>
<blockquote>
<p>这里有个小插曲：虽然发送的数据包中有两种签名信息，但实际上对端<code>memcmp</code>比较两种签名的差异时，并没有保存成功与否的信息，只是把结果log了一下，可能是因为正常情况下两种数据的确是有些差异的，所以即使是正版应用这个校验也不会通过，猜测他们的源码中把验证失败的操作注释掉了，所以才有这一奇怪现象。</p>
<p>不能保证这种验证会出现在未来的版本中。</p>
</blockquote>
<p><code>process_input</code>的验证逻辑是检测是否登录、<code>token2</code>是否为空，第31行不知道，但经测试与验证无关？接下来就简单了，回到Java层，<code>token2</code>随便给个值就好了。</p>
<h2 id="Native层—Token和代码段验证"><a href="#Native层—Token和代码段验证" class="headerlink" title="Native层—Token和代码段验证"></a>Native层—Token和代码段验证</h2><p>再次打包运行，结果是，应用终于能接收输入了，但是运行大概5分钟后，应用又无法接收输入，而且与之前不同，这次连悬浮窗中的“展开通知栏”也没用了。这又双叒叕是一个验证，不过好在这次的验证点比较好找，就在<code>titan::kernel::on_network_event</code>函数<code>case 7</code>下面的<code>case 8</code>。这里判断了<code>uid</code>和<code>token</code>是否为空，然后调用了函数<code>isUidValid(0x18B150)</code>（名字随便起的）用于验证，过程就不展开说了，下面是代码修复结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// local variable allocation has failed, the output may be wrong!</span></span><br><span class="line"><span class="function">__int64 __fastcall <span class="title">isUidValid</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> lentoken2; <span class="comment">// w0</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> _uid; <span class="comment">// w20</span></span><br><span class="line">  <span class="keyword">void</span> *base64_vt; <span class="comment">// x0</span></span><br><span class="line">  _QWORD *base64; <span class="comment">// x20</span></span><br><span class="line">  __int64 tokenbuf; <span class="comment">// x0</span></span><br><span class="line">  _QWORD *tokendbuf; <span class="comment">// x20</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> tokendatalen; <span class="comment">// w21</span></span><br><span class="line">  <span class="keyword">void</span> *v9; <span class="comment">// x0</span></span><br><span class="line">  __int64 buffer; <span class="comment">// x20</span></span><br><span class="line">  __int64 rsa; <span class="comment">// x21</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> blocksize; <span class="comment">// w22</span></span><br><span class="line">  <span class="keyword">int</span> v13; <span class="comment">// w8</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 current; <span class="comment">// x26</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> remain; <span class="comment">// w8</span></span><br><span class="line">  __int64 v16; <span class="comment">// x0</span></span><br><span class="line">  <span class="keyword">int</span> v17; <span class="comment">// w0</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">void</span> *v18; <span class="comment">// x23</span></span><br><span class="line">  __int64 v19; <span class="comment">// x28</span></span><br><span class="line">  __int64 v21; <span class="comment">// x8</span></span><br><span class="line">  __int64 v23; <span class="comment">// [xsp+0h] [xbp-D0h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 expire_time; <span class="comment">// [xsp+8h] [xbp-C8h] BYREF</span></span><br><span class="line">  __int64 token_time; <span class="comment">// [xsp+10h] [xbp-C0h] BYREF</span></span><br><span class="line">  __int64 v26; <span class="comment">// [xsp+18h] [xbp-B8h]</span></span><br><span class="line">  <span class="keyword">int</span> tv; <span class="comment">// [xsp+20h] [xbp-B0h] OVERLAPPED BYREF</span></span><br><span class="line">  _DWORD tv_4[<span class="number">7</span>]; <span class="comment">// [xsp+24h] [xbp-ACh] BYREF</span></span><br><span class="line">  <span class="keyword">void</span> *tokendata; <span class="comment">// [xsp+40h] [xbp-90h] BYREF</span></span><br><span class="line">  __int64 v30; <span class="comment">// [xsp+48h] [xbp-88h]</span></span><br><span class="line">  _BYTE v31[<span class="number">16</span>]; <span class="comment">// [xsp+50h] [xbp-80h] BYREF</span></span><br><span class="line">  <span class="keyword">void</span> *tokendatab64; <span class="comment">// [xsp+60h] [xbp-70h] BYREF</span></span><br><span class="line">  <span class="keyword">size_t</span> tokendatab64len; <span class="comment">// [xsp+68h] [xbp-68h]</span></span><br><span class="line">  <span class="keyword">int</span> uid; <span class="comment">// [xsp+78h] [xbp-58h] OVERLAPPED BYREF</span></span><br><span class="line">  <span class="keyword">int</span> isVip; <span class="comment">// [xsp+7Ch] [xbp-54h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !*(_BYTE *)(a1 + <span class="number">3605</span>) || !*(_BYTE *)(a1 + <span class="number">3640</span>) )<span class="comment">// not login or token2 is &#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  tokendatab64len = <span class="number">0LL</span>;</span><br><span class="line">  tokendatab64 = <span class="number">0LL</span>;</span><br><span class="line">  lentoken2 = strnlen((<span class="keyword">const</span> <span class="keyword">char</span> *)(a1 + <span class="number">3640</span>), <span class="number">0x400</span>uLL);</span><br><span class="line">  _uid = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( (lentoken2 &amp; <span class="number">0xFFFFFC00</span>) != <span class="number">0</span> || lentoken2 &lt; <span class="number">0x21</span> )<span class="comment">// 32 &lt; len &lt; 1024</span></span><br><span class="line">    <span class="keyword">goto</span> LABEL_42;</span><br><span class="line">  alloc((__int64)&amp;tokendatab64, lentoken2 - <span class="number">32</span>);</span><br><span class="line">  <span class="built_in">memcpy</span>(tokendatab64, (<span class="keyword">const</span> <span class="keyword">void</span> *)(a1 + <span class="number">3672</span>), (<span class="keyword">unsigned</span> <span class="keyword">int</span>)tokendatab64len);</span><br><span class="line">  v30 = <span class="number">0LL</span>;</span><br><span class="line">  tokendata = <span class="number">0LL</span>;</span><br><span class="line">  base64_vt = sub_1B1094();</span><br><span class="line">  base64 = (_QWORD *)cipher_init((__int64)base64_vt);</span><br><span class="line">  cipher_addflag((__int64)base64, <span class="number">256</span>);</span><br><span class="line">  tokenbuf = cipher_memory2buffer((<span class="keyword">const</span> <span class="keyword">char</span> *)tokendatab64, tokendatab64len);</span><br><span class="line">  tokendbuf = cipher_decrypt(base64, tokenbuf);</span><br><span class="line">  alloc((__int64)&amp;tokendata, tokendatab64len);</span><br><span class="line">  tokendatalen = cipher_buffer2memory((__int64)tokendbuf, (__int64)tokendata, v30);</span><br><span class="line">  cipher_bufferclear((__int64)tokendbuf);</span><br><span class="line">  <span class="keyword">if</span> ( tokendatalen &gt;= <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    alloc((__int64)&amp;tokendatab64, tokendatalen);</span><br><span class="line">    <span class="built_in">memcpy</span>(tokendatab64, tokendata, tokendatalen);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( tokendata )</span><br><span class="line">    <span class="keyword">operator</span> <span class="keyword">delete</span>[](tokendata);</span><br><span class="line">  v30 = <span class="number">0xF00000000</span>LL;</span><br><span class="line">  tokendata = v31;</span><br><span class="line">  v31[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  v9 = sub_1AC230();</span><br><span class="line">  buffer = cipher_init((__int64)v9);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)cipher_bufferload(buffer, (__int64)&amp;unk_321196, <span class="number">550u</span>) == <span class="number">550</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_QWORD *)&amp;tv_4[<span class="number">1</span>] = <span class="number">0xF00000000</span>LL;</span><br><span class="line">    *(_QWORD *)&amp;tv = &amp;tv_4[<span class="number">3</span>];</span><br><span class="line">    rsa = sub_1C04F8(buffer, <span class="number">0LL</span>);</span><br><span class="line">    LOBYTE(tv_4[<span class="number">3</span>]) = <span class="number">0</span>;</span><br><span class="line">    v26 = <span class="number">0LL</span>;</span><br><span class="line">    token_time = <span class="number">0LL</span>;</span><br><span class="line">    blocksize = sub_1BB5A8(rsa);                <span class="comment">// 0x200</span></span><br><span class="line">    sub_73858((__int64)&amp;token_time, blocksize + <span class="number">1</span>);</span><br><span class="line">    v13 = tokendatab64len;</span><br><span class="line">    <span class="keyword">if</span> ( (_DWORD)tokendatab64len )</span><br><span class="line">    &#123;</span><br><span class="line">      current = <span class="number">0LL</span>;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        remain = v13 - current;</span><br><span class="line">        <span class="keyword">if</span> ( (<span class="keyword">int</span>)remain &lt;= (<span class="keyword">int</span>)blocksize )</span><br><span class="line">          v16 = remain;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          v16 = blocksize;</span><br><span class="line">        v17 = sub_1BB624(v16, (__int64)tokendatab64 + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)current, token_time, rsa);<span class="comment">// 1BCF50</span></span><br><span class="line">        <span class="keyword">if</span> ( v17 &gt;= <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          *(_BYTE *)(token_time + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v17) = <span class="number">0</span>;</span><br><span class="line">          v18 = (<span class="keyword">const</span> <span class="keyword">void</span> *)token_time;</span><br><span class="line">          <span class="keyword">if</span> ( *(_BYTE *)token_time )</span><br><span class="line">          &#123;</span><br><span class="line">            v19 = <span class="number">0LL</span>;</span><br><span class="line">            <span class="keyword">while</span> ( *(<span class="keyword">unsigned</span> __int8 *)(token_time + v19++ + <span class="number">1</span>) )</span><br><span class="line">              ;</span><br><span class="line">            <span class="keyword">if</span> ( (_DWORD)v19 )</span><br><span class="line">            &#123;</span><br><span class="line">              sub_71604((__int64)&amp;tokendata, v30 + v19);</span><br><span class="line">              <span class="built_in">memcpy</span>((<span class="keyword">char</span> *)tokendata + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v30, v18, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v19);</span><br><span class="line">              LODWORD(v30) = v30 + v19;</span><br><span class="line">              *((_BYTE *)tokendata + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v30) = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        v13 = tokendatab64len;</span><br><span class="line">        current += (<span class="keyword">int</span>)blocksize;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( current &lt; (<span class="keyword">unsigned</span> <span class="keyword">int</span>)tokendatab64len );</span><br><span class="line">    &#125;</span><br><span class="line">    sub_1BB9CC(rsa);</span><br><span class="line">    <span class="keyword">if</span> ( token_time )</span><br><span class="line">      <span class="keyword">operator</span> <span class="keyword">delete</span>[]((<span class="keyword">void</span> *)token_time);</span><br><span class="line">    <span class="keyword">if</span> ( *(_QWORD *)&amp;tv &amp;&amp; &amp;tv_4[<span class="number">3</span>] != *(_DWORD **)&amp;tv )</span><br><span class="line">      <span class="keyword">operator</span> <span class="keyword">delete</span>[](*(<span class="keyword">void</span> **)&amp;tv);</span><br><span class="line">  &#125;</span><br><span class="line">  sub_1AA098(buffer);</span><br><span class="line">  <span class="keyword">if</span> ( !(_DWORD)v30 )</span><br><span class="line">  &#123;</span><br><span class="line">    _uid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_39;</span><br><span class="line">  &#125;</span><br><span class="line">  *(_QWORD *)&amp;uid = <span class="number">0LL</span>;</span><br><span class="line">  expire_time = <span class="number">0LL</span>;</span><br><span class="line">  token_time = <span class="number">0LL</span>;</span><br><span class="line">  v23 = <span class="number">0LL</span>;</span><br><span class="line">  tv = <span class="number">53</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>((<span class="keyword">char</span> *)tv_4, <span class="string">&quot;%d|%d|%lu|%lu|%lu&quot;</span>);</span><br><span class="line">  _uid = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">sscanf</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)tokendata, (<span class="keyword">const</span> <span class="keyword">char</span> *)tv_4, &amp;isVip, &amp;uid, &amp;token_time, &amp;expire_time, &amp;v23) != <span class="number">5</span></span><br><span class="line">    || isVip != <span class="number">1</span></span><br><span class="line">    || (_uid = uid) == <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_39:</span><br><span class="line">    <span class="keyword">if</span> ( !tokendata )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_42;</span><br><span class="line">LABEL_40:</span><br><span class="line">    <span class="keyword">if</span> ( v31 != tokendata )</span><br><span class="line">      <span class="keyword">operator</span> <span class="keyword">delete</span>[](tokendata);</span><br><span class="line">    <span class="keyword">goto</span> LABEL_42;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( token_time &lt; expire_time &amp;&amp; _uid == atoi((<span class="keyword">const</span> <span class="keyword">char</span> *)(a1 + <span class="number">3624</span>)) )</span><br><span class="line">  &#123;</span><br><span class="line">    gettimeofday((struct timeval *)&amp;tv, <span class="number">0LL</span>);   <span class="comment">// current second</span></span><br><span class="line">    v21 = *(_QWORD *)&amp;tv - token_time;</span><br><span class="line">    <span class="keyword">if</span> ( *(_QWORD *)&amp;tv - token_time &lt; <span class="number">0</span> )</span><br><span class="line">      v21 = token_time - *(_QWORD *)&amp;tv;</span><br><span class="line">    _uid = v21 &lt; <span class="number">172800</span>;                        <span class="comment">// 2 day</span></span><br><span class="line">    <span class="keyword">if</span> ( !tokendata )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_42;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_40;</span><br><span class="line">  &#125;</span><br><span class="line">  _uid = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( tokendata )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_40;</span><br><span class="line">LABEL_42:</span><br><span class="line">  <span class="keyword">if</span> ( tokendatab64 )</span><br><span class="line">    <span class="keyword">operator</span> <span class="keyword">delete</span>[](tokendatab64);</span><br><span class="line">  <span class="keyword">return</span> _uid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的不同时期变量在栈中会重叠，所以一个变量名可能对应好几种意思。函数的逻辑是，抛开<code>token2</code>的前32字节不谈，<code>base64</code>解密<code>token2</code>剩下的部分，然后用<code>0x321196</code>处的<code>der</code>格式证书中的公钥解密<code>token2</code>，如果解密成功，会得到一个<code>&lt;isVip&gt;|&lt;uid&gt;|&lt;token_timestamp&gt;|&lt;expire_timestamp&gt;|&lt;uuid&gt;</code>格式的字符串，然后应用对这个字符串作进一步的分析。由于是RSA，私钥没办法获取，所以必须把<code>0x321196</code>处的证书替换成我们自己的。</p>
<blockquote>
<p>Q：为什么不直接改代码让这函数返回1？</p>
<p>A：这里偷了一个懒，如果改.text段，要在三个so中分别找到这个函数的位置，改证书只要调用<code>bytes.find()</code>就可以直接处理三个文件。另一方面，之前修改.text段发现有另一个验证，这个后面再说。</p>
</blockquote>
<p>用python生成自己的证书替换掉原证书，然后生成一个我们自己的<code>token2</code>，我发现python<code>Crypto</code>库里面竟然没有私钥加密公钥解密的函数？？？然后自己写了一个：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> unhexlify</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64encode</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span>(<span class="params">data: <span class="built_in">bytes</span>, key: RSA.RsaKey</span>):</span></span><br><span class="line">    lenkey = (key.n.bit_length() + <span class="number">7</span>) &gt;&gt; <span class="number">3</span></span><br><span class="line">    <span class="keyword">assert</span> lenkey &gt; <span class="number">11</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(data) + <span class="number">11</span> &lt;= lenkey</span><br><span class="line">    datapad = <span class="string">b&#x27;\x00\x01&#x27;</span> + <span class="string">b&#x27;\xff&#x27;</span> * (lenkey - <span class="number">3</span> - <span class="built_in">len</span>(data)) + <span class="string">b&#x27;\x00&#x27;</span> + data</span><br><span class="line">    enc = <span class="built_in">pow</span>(<span class="built_in">int</span>.from_bytes(datapad, <span class="string">&#x27;big&#x27;</span>), key.d, key.n)</span><br><span class="line">    <span class="keyword">return</span> enc.to_bytes(lenkey, <span class="string">&#x27;big&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span>(<span class="params">data: <span class="built_in">bytes</span>, key: RSA.RsaKey</span>):</span></span><br><span class="line">    lenkey = (key.n.bit_length() + <span class="number">7</span>) &gt;&gt; <span class="number">3</span></span><br><span class="line">    <span class="keyword">assert</span> lenkey &gt; <span class="number">11</span> <span class="keyword">and</span> <span class="built_in">len</span>(data) == lenkey</span><br><span class="line">    dec = <span class="built_in">pow</span>(<span class="built_in">int</span>.from_bytes(data, <span class="string">&#x27;big&#x27;</span>), key.e, key.n).to_bytes(lenkey, <span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(dec):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>: <span class="keyword">assert</span> c == <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> i == <span class="number">1</span>: <span class="keyword">assert</span> c == <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> c != <span class="number">255</span>:</span><br><span class="line">                <span class="keyword">assert</span> c == <span class="number">0</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="keyword">assert</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> dec[i:]</span><br><span class="line"></span><br><span class="line">key = RSA.import_key(<span class="built_in">open</span>(<span class="string">&#x27;new.der&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read())</span><br><span class="line">key1 = RSA.import_key(<span class="built_in">open</span>(<span class="string">&#x27;export.der&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read())</span><br><span class="line">raw = <span class="string">b&#x27;1|1|0|2147483647|0&#x27;</span></span><br><span class="line">enc = encrypt(raw, key)</span><br><span class="line"><span class="keyword">assert</span> decrypt(enc, key1) == raw</span><br><span class="line"><span class="built_in">open</span>(<span class="string">&#x27;../patch/token.txt&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>).write(<span class="string">b&#x27;A&#x27;</span> * <span class="number">32</span> + b64encode(enc))</span><br></pre></td></tr></table></figure>
<p>把这个<code>token2</code>放到Java层对应的字段即可。然而重新打包运行发现然并卵。再往后一看，原来后面还有个<code>token2</code>的时间验证，有效期为两天内！于是我们不得不修改.text段了（<del>mmp，证书白做了，<code>isUidValid</code>也白分析了，最终还是得修改.text，逸一时误一世啊</del>），而.text段有另一处验证，没办法继续找吧(＠_＠) 。。。</p>
<p>继续用日志对比大法，把.text段是否修改作为控制变量，最终找到了这个：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@1809@@1014@</span><br></pre></td></tr></table></figure>
<p>根据这个字符串寻找对应的代码，最终找到了<code>xxxVerifyCodeModify(0x13A724)</code>(除了<code>gettime</code>外这里的函数名都是随便起的)：</p>
<p><img src="/img/loading.svg" data-original="/pictures/VPhone-Reverse/15.png" alt="text段验证"></p>
<p><code>IsDebuggerPresent</code>会读取<code>/proc/self/status</code>中的<code>TracerPid</code>来检测自身是否被调试：</p>
<p><img src="/img/loading.svg" data-original="/pictures/VPhone-Reverse/16.png" alt="检测调试器"></p>
<p><code>codeNotModified</code>读取参数二指定的文件，对它的.plt和.text段进行MD5校验，然后与参数三进行对比：</p>
<p><img src="/img/loading.svg" data-original="/pictures/VPhone-Reverse/17.png" alt="检测代码段"></p>
<p>剩下的就简单了，修改返回值或者MD5即可。这里选择了后者，因为在三个<code>libuserkernel*.so</code>中MD5字节可以用python推算出来然后自动修改，而修改返回值得动代码，要分别在三个版本的so中找，挺麻烦的。</p>
<h2 id="再补充点小细节，完成"><a href="#再补充点小细节，完成" class="headerlink" title="再补充点小细节，完成"></a>再补充点小细节，完成</h2><p>这回打包运行终于没问题了，我重新捋一下要破解的位置，写了个完整的脚本，然后再次打包运行，能启动了！！！结果还没高兴30秒应用又崩溃了（′⌒`；）不知道是忽略了什么，但是之前搜签名的SHA1的时候搜到一个奇怪的位置：<code>Engine::DoVerifyLocal(0x1DD984)</code>，它里面除了签名的哈希值外，还有一个设置30秒定时器的操作，与现在的情况比较相符，尝试性的改了一下，然后运行成功。应用打开放着跑了半个小时，终于没有什么奇怪的现象了，只是手动打开登录界面，点击退出登录时（实际上自己并未登录，登录效果是改smali代码改出来的），会提示你充vip。这个是小问题，找到对应xml把那些控件隐藏就OK了。至此，光速虚拟机的破解完结撒花~~</p>
<h2 id="逆向时的奇怪问题"><a href="#逆向时的奇怪问题" class="headerlink" title="逆向时的奇怪问题"></a>逆向时的奇怪问题</h2><p>我在逆向时还是走了很多弯路的，尤其是C++的<code>std::string</code>在编译内联后产生的代码，老人地铁手机.jpg：</p>
<p><img src="/img/loading.svg" data-original="/pictures/VPhone-Reverse/18.png" alt="std::string"></p>
<p>在这个应用的so中，有大量的这种代码，所以有必要先搞清楚它的结构。<code>std::string</code>的结构是这样的：</p>
<ul>
<li><p><code>sizeof (std::string) == 24</code>。</p>
</li>
<li><p>如果字符串长度（含终止<code>\0</code>）不超过23，那么结构体第一个字节是<code>strlen(s) * 2</code>，剩下的空间用来存放字符串，这样就可以不用在堆上分配内存从而提高效率。</p>
</li>
<li><p>如果字符串长度不满足上述条件，那么结构体最后八字节是指向真正字符串的指针，中间八字节是字符串长度，前八字节是为字符串申请的堆空间的长度加1，由于分配以16字节对齐，所以查看第一字节的第0位是否为1即可区别出字符串是哪一种情况。</p>
</li>
<li><p>数据结构的示意代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">string</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                <span class="keyword">uint8_t</span> isLongString: <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">uint8_t</span> shortStringLen: <span class="number">7</span>;</span><br><span class="line">                <span class="keyword">char</span> astr[<span class="number">23</span>];</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                <span class="keyword">size_t</span> spaceLenPlus1;</span><br><span class="line">                <span class="keyword">size_t</span> stringLen;</span><br><span class="line">                <span class="keyword">char</span> *pstr;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 取C风格字符串指针</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> isLongString ? pstr : astr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取长度</span></span><br><span class="line">        <span class="function"><span class="keyword">size_t</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> isLongString ? stringLen : shortStringLen;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>像开头那段IDA反编译的代码，事实上是把<code>(std::string)var_2F8</code>字符串存储到<code>a1</code>（类指针）的一个成员变量里，乱七八糟的代码是拷贝构造函数内联后的杰作：如果<code>(a1 + 1368) != var_2F8</code> （肯定不相等，因为<code>a1</code>在堆上，<code>var_2F8</code>反编译时是个数组在栈上，但拷贝构造函数不知道这一点，它只知道两个指针相等就不用复制了。我在开始的时候没看懂这段代码，然后就很迷茫），就把后者调整为<code>const char *</code>指针并传入以它和它的长度为参数的构造函数<code>sub_6F400</code>。所以实际上源码中可能只是一个简单的<code>engine.uidStored = uid;</code>，然后得益于C++函数的内联，生成的代码就成了这副样子。</p>
<p>在逆向时发现的其他奇怪之处：</p>
<ul>
<li><p><code>verifyfunction_doVerifyKernelSignature(0x1D95A8)</code>处，看名称和逻辑猜测也是验证函数，但好像没有任何地方调用它？</p>
</li>
<li><p><code>Engine::DoVPhoneVerifyLocal(0x1DD984)</code>处，确实是在验签，目前仍不清楚触发条件，只知道修改了<code>libVphoneGaGaLib.so</code>的某处后启动时触发，然而我无法复现不触发的情况了，索性让函数直接返回。</p>
</li>
<li><p><code>0x174124</code>、<code>0x16F378</code>、<code>0x1D91C4</code>和<code>0x17191C</code>处的函数，对字符串的分析发现它们都与签名/验证有关，然而最后没有修改这几项仍然正常运行，就先不改了吧。</p>
</li>
<li><p><code>xxxRegisterTimer(0x7B854)</code>，名字随便起的：函数会设置一个定期调用回调函数的定时器，但是最后两个参数都是时间，猜测第一个是第一次调用的间隔时间，第二个是其余调用的间隔时间，但是有几个对此函数的调用逻辑又说不通？</p>
</li>
</ul>
<h2 id="梳理应用验证流程"><a href="#梳理应用验证流程" class="headerlink" title="梳理应用验证流程"></a>梳理应用验证流程</h2><p>总的来说，这个应用在防破解方面还是做了很多工作的，具体如下：</p>
<ul>
<li><p>引擎启动时，直接读取安装包中的<code>META-INF/KEY0.RSA</code>，进行签名的验证（这也就是在Java层拦截签名函数无效的原因）。验证失败则提示<code>initialize feature fail!</code>。</p>
</li>
<li><p>虚拟机启动时，通过<code>lib</code>位置间接获取安装包路径（Java层修改<code>mAppDir</code>劫持路径无效的原因），读取其中的几个关键文件（<code>classes*.dex</code>，<code>AndroidManifest.xml</code>），检查它们的长度和Crc32，检查结果先放入成员变量中，启动后如果发现它为0就不进行画面渲染等等。另一方面，有一个触发时间为启动后、触发条件未知的函数，它也会检测应用签名，如果失败就设置一个延迟时间为30秒的timer，timer回调时应用崩溃。</p>
</li>
<li><p>Java层材料（相关类名是<code>Lcom/vphonegaga/titan/personalcenter/beans/MaterialBean$Material;</code>）包含VIP的特权和过期时间等信息，它会传入<code>libVphoneGaGaLib.so</code>，后者访问<code>https://dcdn.appmarket.api.gsxnj.cn/api2/*.php</code>和<code>https://dcdn.appmarket.api.gsxnj.cn/api/time.php</code>进行联网校验，其中安卓10特权校验成功时才生成输入数据包（触摸事件等等）。另一方面<code>libVPhoneGaGaLib.so</code>会主动获取Java层中包含<code>token2</code>等数据的应用登录信息（相关类名<code>Lcom/vphonegaga/titan/user/User;</code>），然后通过socket发给<code>libuserkernel*.so</code>，<code>token2</code>和时间验证成功后输入数据包才被接受。</p>
</li>
<li><p><code>libuserkernel*.so</code>中记录了一个时间戳<code>T</code>，初始值为启动时间（猜测）。应用不定期获取时间，当超过<code>T</code>4分钟就发送一条信息给<code>libVPhoneGaGaLib.so</code>要求更新<code>T</code>的值，当超过<code>T</code>5分钟就故意陷入无限等待，这时虚拟机就无法正常使用了。但是，从用户登录起，每过3分钟<code>libVPhoneGaGaLib.so</code>就会主动把<code>token2</code>、<code>uid</code>之类的信息发送给<code>libuserkernel*.so</code>，后者用非对称算法验证<code>token2</code>的有效性，只有合法才会更新<code>T</code>的值。当<code>T</code>更新后，除非再过5分钟，否则不会停机，而如果<code>libVPhoneGaGaLib.so</code>一直每隔3分钟发送正确的信息，那么停机永远不会触发，虚拟机就正常运行了。<del>草，什么摇篮系统</del></p>
</li>
<li><p><code>libuserkernel*.so</code>有<code>ptrace</code>反调试和运行时代码验证：用自身的.plt和.text段计算MD5，并与.data段中某处的值做对比，有差别就陷入无限等待，导致虚拟机启动一直卡在0%处。</p>
</li>
</ul>
<p>应用的代码很多，而且很多验证失败的现象并不能提供什么线索，加上代码是C++编译的，关键函数并不好找。然而写入日志的符号信息让逆向分析难度降低了不少，上面的破解思路基本上是围绕着日志输出展开的。如果应用对日志采用了很复杂的加密方法，或者说对关键代码使用了ollvm，vmp之类的手段加固的话，逆向分析难度还是很大的。</p>
<h2 id="最后的修改清单"><a href="#最后的修改清单" class="headerlink" title="最后的修改清单"></a>最后的修改清单</h2><blockquote>
<p>因特殊原因，这里把具体的修改位置删掉了。逆向时遇到问题可以私聊。</p>
</blockquote>
<p>把改好的4个so与原so替换，然后就可以优雅地对应用进行签名了，最后附上安卓10面具安装成功的效果图：</p>
<p><img src="/img/loading.svg" data-original="/pictures/VPhone-Reverse/19.png" alt="破解成功"></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></article><div class="post-copyright"><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://killtimer0.github.io/2022/08/30/VPhone-Reverse/">https://killtimer0.github.io/2022/08/30/VPhone-Reverse/</a></span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/reverse/">reverse</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/09/21/Mixed01/"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">大杂烩</div></div></a></div><div class="next-post pull-right"><a href="/2022/01/15/XDCTF/"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">“抗疫”CTF题解</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/09/20/test-sort/" title="C中的qsort真的比C++中的std::sort快吗?"><img class="cover" src="/img/loading.svg" data-original="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-20</div><div class="title">C中的qsort真的比C++中的std::sort快吗?</div></div></a></div><div><a href="/2021/11/04/Hackergame2021/" title="Hackergame 2021"><img class="cover" src="/img/loading.svg" data-original="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-04</div><div class="title">Hackergame 2021</div></div></a></div><div><a href="/2022/01/15/XDCTF/" title="“抗疫”CTF题解"><img class="cover" src="/img/loading.svg" data-original="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-15</div><div class="title">“抗疫”CTF题解</div></div></a></div><div><a href="/2022/09/21/Mixed01/" title="大杂烩"><img class="cover" src="/img/loading.svg" data-original="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-21</div><div class="title">大杂烩</div></div></a></div><div><a href="/2021/09/26/moectf/" title="moectf 题解记录"><img class="cover" src="/img/loading.svg" data-original="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-26</div><div class="title">moectf 题解记录</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/loading.svg" data-original="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">KillTimer</div><div class="author-info__description">休息一下吧，去看个书好不好</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/killtimer0" target="_blank" title="GitHub"><i class="iconfont icon-github"></i></a><a class="social-icon" href="mailto:1837009039@qq.com" target="_blank" title="QQ"><i class="iconfont icon-qq"></i></a><a class="social-icon" href="https://www.bilibili.com" target="_blank" title="哔哩哔哩"><i class="iconfont icon-bilibili"></i></a><a class="social-icon" href="/game.html" target="_blank" title="彩蛋"><i class="iconfont icon-egg-c"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%B1%82%E5%88%9D%E6%8E%A2"><span class="toc-number">1.</span> <span class="toc-text">Java层初探</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Native%E5%B1%82%E2%80%94%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81"><span class="toc-number">2.</span> <span class="toc-text">Native层—签名验证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Native%E5%B1%82%E2%80%94%E6%95%B0%E6%8D%AE%E9%AA%8C%E8%AF%81"><span class="toc-number">3.</span> <span class="toc-text">Native层—数据验证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Native%E5%B1%82%E2%80%94VIP%E9%AA%8C%E8%AF%81"><span class="toc-number">4.</span> <span class="toc-text">Native层—VIP验证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Native%E5%B1%82%E2%80%94Token%E5%92%8C%E4%BB%A3%E7%A0%81%E6%AE%B5%E9%AA%8C%E8%AF%81"><span class="toc-number">5.</span> <span class="toc-text">Native层—Token和代码段验证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%8D%E8%A1%A5%E5%85%85%E7%82%B9%E5%B0%8F%E7%BB%86%E8%8A%82%EF%BC%8C%E5%AE%8C%E6%88%90"><span class="toc-number">6.</span> <span class="toc-text">再补充点小细节，完成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%86%E5%90%91%E6%97%B6%E7%9A%84%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98"><span class="toc-number">7.</span> <span class="toc-text">逆向时的奇怪问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A2%B3%E7%90%86%E5%BA%94%E7%94%A8%E9%AA%8C%E8%AF%81%E6%B5%81%E7%A8%8B"><span class="toc-number">8.</span> <span class="toc-text">梳理应用验证流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%90%8E%E7%9A%84%E4%BF%AE%E6%94%B9%E6%B8%85%E5%8D%95"><span class="toc-number">9.</span> <span class="toc-text">最后的修改清单</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By KillTimer</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(() => {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'forest',
      })
      false && mermaid.init()
    })
  }
}</script></div></div><script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},t.src!==i&&(n.src=i)}()}o(),n.addEventListener("scroll",function(){var t,e;t=o,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script><script src="https://cdn.jsdelivr.net/npm/live2d-widget@^3.1.3/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({"pluginRootPath":"npm/live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"https://cdn.jsdelivr.net/npm/live2d-widget-model-hijiki@1.0.5/assets/hijiki.model.json"},"display":{"position":"right","width":87,"height":189,"hOffset":20},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.8},"log":false});</script></body></html>